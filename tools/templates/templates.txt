headers:
/********************************************
* Generated: {date_time}                    *
********************************************/

#include <stdio.h>
#include "headers/stack.h"
#include "headers/func.h"


node_t:

// this holds the string you are tokenizing
typedef struct{
    int   length;
    int   pos;
    void *value;
    stack_t *stack;
}
node_t;

stricmp:


// node values are only compared if string length is the same, no need to validate
// comparitors is against a precompiled value thats already case optimised
// returns 0 for equal
int stricmp(node_t *n, char const *b){
    int d=0;
    for (int i=0;i<n->len;i++) {
        d = tolower(node[i]) - b[i];
        if (d != 0 ) return d;
    }
    return 0;
}

or:
// or group
if( n->pos!=-1 && n->OK==1) {
    push(n->stack,n->pos); //save position
    {body}
    pop(n->stack); //remove saved position
}//end ok

or_list_item:
// well this
if (n->OK!=1) {  //if bad, retry wrapper
    n->OK=1; 
    n->pos=peek(n->stack); 
{body}
}
//then that

one_or_more:
push(n->stack,n->pos);              // one or more
if( n->pos!=-1 && n->OK==1) {
push(n->stack,n->pos);
{body}
if(n->OK==0) { n->pos=peek(n->stack); }      // one or more loop OK test
pop(n->stack);
} // end one or more
if(n->pos>==peek(n->stack)){ n->OK=0; }      // one or more OK test
pop(n->stack);
                                                            

zero_or_more:
if( n->pos!=-1 && n->OK==1) {
push(n->stack,n->pos);              // zero or more
{body}
if(n->OK==0) { n->pos=peek(n->stack); }      // weo or more loop OK test
} // end zero or more
pop(n->stack);




compare:
if( n->pos!=-1 && n->OK==1 && n->len=={compare_value_length} && strcmpi(n, '{compare_value}')==0) {
    n->OK=1;
    n->pos+={compare_value_length};
    if(n->pos>=n->len) n->pos= -1;
} else {
    n->OK=0;
}

optional:
// begin optional block
if ( node =! NULL ) {
    node_t * {node_uid}=node;
{body}
    if ( node == NULL ) node={node_uid};
} // end optional block


compare_function:

// Function : match_{function_name}
node_t * match_{function_name}(node_t *n){
{body}
return n;
}

match_functions:
/*
 * Function: match_functions
 * -----------------------------
 *   Generated: {date_time}
 *      nodes: a pointer to the curent element in a linked list of nodes to search
 * 
 *     OK: Returns a the node AFTER the curent pattern match
 *              If the end of the list is reached the last node is passed
 *     Failure: Returns NULL
 */
node_t * match_function(char *data) {
    node_t * n=malloc(sizeof(node_t));
    n->value=data;
    n->len=strlen(data);
    n->pos=0;
    n->stack=createStack(100);

{body}
    return n;
} // end match functions


match_functions_first_var:
    n=match_{function_name}(nodes);

match_functions_second_var:
    if (n.pos!=-1 && n->OK=1) return node; 
    n=match_{function_name}(nodes);




not:
//NOT
if( n->pos!=-1 && n->OK==1) {
    push(n->stack,n->pos);
    {body}
    if (n->OK==1) {
        n->OK=0;
        n->pos=peek(n->stack);
    } else { 
        n->OK=1;
    }
    pop(n->stack);
}//end NOT

range:
(n->value[n->pos]>='{range_1}' && n->value[n->pos]<='{range_2}')

char:
if( n->pos!=-1 && n->OK==1 && ( 
{conditions}
) ) {
    n->OK=1;
    n->pos++; 
    if(n->pos>=n->len) n->pos= -1;
} else {     
    n->OK=0;
} // end char

or_compare:
 n->value[n->pos]=='{compare_value}'

compare_method:
if( n->pos!=-1 && n->OK==1 ) { n = match_{function_name}(n); } //compare_function


group:
// begin group block
if( n->pos!=-1 && n->OK==1) {
{body}
} // end group block

signature:
node_t * match_{body}(node_t *n);
