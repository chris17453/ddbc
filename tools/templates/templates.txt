 # node->value     = memory pointer
 # node->OK   = 0=False, 1=True
 # node->len    = length of memory
 # node->pos     = character position in memory, -1  is past length of memory
 # node->pin       = pinned character position for an inner loop
 # node->big_pin   = pinned character position for an outer loop


strcicmp:
int strcicmp(char const *a, char const *b)
{
    for (;; a++, b++) {
        int d = tolower((unsigned char)*a) - tolower((unsigned char)*b);
        if (d != 0 || !*a)
            return d;
    }
}
# temp_position, bopdy
or:
// or
if( node->pos!=-1 && node->OK==1) {
    token={temp_position};
{body}

}

# temp_position, bopdy
one_or_more:
node->big_pin=node->pos;              // one or more
if( node->pos!=-1 && node->OK==1) {
node->pin=node->pos;              // one or more
{body}
if(node->OK==0) { node->pos=node->pin; }      // one or more loop OK test
} // end one or more
if(node->pos>==node->big_pin){ node->OK=0; }      // one or more OK test
                                                            

zero_or_more:
if( node->pos!=-1 && node->OK==1) {
node->pin=node->pos;              // zero or more
{body}
if(node->OK==0) { node->pos=node->pin; }      // weo or more loop OK test
} // end zero or more


not:
//NOT X


#compare_value
compare:
if( node->pos!=-1 && node->OK==1 && token->len=={compare_value_length} && strcmpi(node,'{compare_value}')==0) {
    node->OK=1;
    node->pos+={compare_value_length};
    if(node->pos>=node->len) node->pos= -1;
} else {
    node->OK=0;
}

# token_uid,body
optional:
// begin optional block
if ( token =! NULL ) {
    token_t * {token_uid}=token;
{body}
    if ( token == NULL ) token={token_uid};
} // end optional block


# function_name, date_time
compare_function:

// Function : match_{function_name}
// Generated: {date_time}
node_t * match_{function_name}(node_t *hay){
{body}
return node;
}

# body
match_functions:
/*
 * Function: match_functions
 * -----------------------------
 *   Generated: {date_time}
 *      tokens: a pointer to the curent element in a linked list of tokens to search
 * 
 *     OK: Returns a the token AFTER the curent pattern match
 *              If the end of the list is reached the last token is passed
 *     Failure: Returns NULL
 */
node_t * match_function(node_t* node) {
    token_t * token=NULL;";
{body}
    return token;
} // end match functions


# function_name
match_functions_first_var:
    token=match_{function_name}(tokens);

# function_name
match_functions_second_var:
    if (token!=NULL) return token; token=match_{function_name}(tokens);



# *      tokens: a pointer to the curent element in a linked list of tokens to search
# * 
# *     OK: Returns a the token AFTER the curent pattern match
# *              If the end of the list is reached the last token is passed
# *     Failure: Returns NULL
 


 # range_1,range_2
range:
(node->value[node->pos]>='{range_1}' && node->value[node->pos]<='{range_2}')

char:
if( node->pos!=-1 && node->OK==1 && ( 
{conditions}
) ) {
    node->OK=1;
    node->pos++; 
    if(node->pos>=node->len) node->pos= -1;
} else {     
    node->OK=0;
} // end char

or_compare:
 node->value[node->pos]=='{compare_value}'

# function_name
compare_method:
if( node->pos!=-1 && node->OK==1 ) { node = match_{function_name}(node); } //compare_function

# body
group:
// begin group block
if( node->pos!=-1 && node->OK==1) {
{body}
} // end group block
