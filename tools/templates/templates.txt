range: token_value2,token_value2
// range
if ( token != NULL && token_cmp_range(token,'{token_value1}','{token_value2}') != NULL ) token=next_token(token);

or: temp_position, bopdy
// or
if ( token == NULL ) {
    token={temp_position};
    {body}
}

compare: compare_value
if ( token != NULL && token_cmp(token,'{compare_value}') != NULL ) token=next_token(token);

compare_function:
//compare_function
if ( token != NULL ) token = match_{function_name}(token);

optional: token_uid,body
// begin optional block
if ( token =! NULL ) {
    token_t * {token_uid}=token;
    {body}
    if ( token == NULL ) token={token_uid};
} // end optional block

optional: body
// begin group block
if ( token =! NULL ) {
    {body}
} // end group block


compare_function: func_name, date_time
/*
 * Function: match_{func_name}
 * -----------------------------
 *   Generated: {date_time}
 *      tokens: a pointer to the curent element in a linked list of tokens to search
 * 
 *     Success: Returns a the token AFTER the curent pattern match
 *              If the end of the list is reached the last token is passed
 *     Failure: Returns NULL
 */
token_t * match_{func_name}(haystack *hay){{
    // {0}: {2}
    token_t * token=token(hay);                //make a copy of the pointer

    {body}

    return token;
}

match_functions: body
/*
 * Function: match_functions
 * -----------------------------
 *   Generated: {0}
 *      tokens: a pointer to the curent element in a linked list of tokens to search
 * 
 *     Success: Returns a the token AFTER the curent pattern match
 *              If the end of the list is reached the last token is passed
 *     Failure: Returns NULL
 */
token_t * match_function(token_t* tokens) {
    token_t * token=NULL;";
    {body}
    return token;
} // end match functions