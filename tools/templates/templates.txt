 # node->value     = memory pointer
 # node->OK   = 0=False, 1=True
 # node->len    = length of memory
 # node->pos     = character position in memory, -1  is past length of memory


strcicmp:
int strcicmp(char const *a, char const *b)
{
    for (;; a++, b++) {
        int d = tolower((unsigned char)*a) - tolower((unsigned char)*b);
        if (d != 0 || !*a)
            return d;
    }
}
# temp_position, bopdy

or:
// or group
if( node->pos!=-1 && node->OK==1) {
    push(node->pos); //save position
    {body}
    pop(); //remove saved position
}//end ok

or_list_item:
// well this
if (node->OK!=1) {  //if bad, retry wrapper
    node->OK=1; 
    node->pos=peek(); 
{body}
}
//then that

# temp_position, bopdy
one_or_more:
push(node->pos);              // one or more
if( node->pos!=-1 && node->OK==1) {
push(node->pos);
{body}
if(node->OK==0) { node->pos=peek(); }      // one or more loop OK test
pop();
} // end one or more
if(node->pos>==peek()){ node->OK=0; }      // one or more OK test
pop();
                                                            

zero_or_more:
if( node->pos!=-1 && node->OK==1) {
push(node->pos);              // zero or more
{body}
if(node->OK==0) { node->pos=peek(); }      // weo or more loop OK test
} // end zero or more
pop();




#compare_value
compare:
if( node->pos!=-1 && node->OK==1 && node->len=={compare_value_length} && strcmpi(node, '{compare_value}')==0) {
    node->OK=1;
    node->pos+={compare_value_length};
    if(node->pos>=node->len) node->pos= -1;
} else {
    node->OK=0;
}

# node_uid,body
optional:
// begin optional block
if ( node =! NULL ) {
    node_t * {node_uid}=node;
{body}
    if ( node == NULL ) node={node_uid};
} // end optional block


# function_name, date_time
compare_function:

// Function : match_{function_name}
// Generated: {date_time}
node_t * match_{function_name}(node_t *hay){
{body}
return node;
}

# body
match_functions:
/*
 * Function: match_functions
 * -----------------------------
 *   Generated: {date_time}
 *      nodes: a pointer to the curent element in a linked list of nodes to search
 * 
 *     OK: Returns a the node AFTER the curent pattern match
 *              If the end of the list is reached the last node is passed
 *     Failure: Returns NULL
 */
node_t * match_function(node_t* node) {
    node_t * node=NULL;";
{body}
    return node;
} // end match functions


# function_name
match_functions_first_var:
    node=match_{function_name}(nodes);

# function_name
match_functions_second_var:
    if (node!=NULL) return node; node=match_{function_name}(nodes);



# *      nodes: a pointer to the curent element in a linked list of nodes to search
# * 
# *     OK: Returns a the node AFTER the curent pattern match
# *              If the end of the list is reached the last node is passed
# *     Failure: Returns NULL
 
not:
//NOT
if( node->pos!=-1 && node->OK==1) {
    push(node->pos);
    {body}
    if (node->OK==1) {
        node->OK=0;
        node->pos=peek()
    } else { 
        node->OK=1;
    }
    pop()
}//end NOT

 # range_1,range_2
range:
(node->value[node->pos]>='{range_1}' && node->value[node->pos]<='{range_2}')

char:
if( node->pos!=-1 && node->OK==1 && ( 
{conditions}
) ) {
    node->OK=1;
    node->pos++; 
    if(node->pos>=node->len) node->pos= -1;
} else {     
    node->OK=0;
} // end char

or_compare:
 node->value[node->pos]=='{compare_value}'

# function_name
compare_method:
if( node->pos!=-1 && node->OK==1 ) { node = match_{function_name}(node); } //compare_function

# body
group:
// begin group block
if( node->pos!=-1 && node->OK==1) {
{body}
} // end group block
