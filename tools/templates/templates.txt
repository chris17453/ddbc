headers:
/********************************************
* Generated: {date_time}                    *
********************************************/

#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include "headers/stack.h"
#include "headers/func.h"


node_t:

// this holds the string you are tokenizing
typedef struct node_t{
    int   len;
    int   pos;
    int   OK;
    int   depth;
    char  *value;
    struct stack_t *stack;
}
node_t;

or:
//OR
if( n_OK(n)==1 ) {
    push(n->stack,n->pos);
    {body}
    pop(n->stack);
}


or_list_item_self:
//item {order}  //skip if not called by self
if (strcmp(name,last_method)!=0 ) {
    n->OK=0;
}

or_list_item1:
//item {order} 
{body}
if (n->OK==0) {
    n->pos=peek(n->stack); 
}

or_list_item+1:
//item+1 {order}
if (n->OK==0 ) {
n->OK=1;
{body}
    if (n->OK==0) {
        n->pos=peek(n->stack); 
    }
} 


one_or_more:
//one or more
push(n->stack,n->pos);
while( n_OK(n)==1 ) {
    push(n->stack,n->pos);
    {body}
    if(n->OK==0) { n->pos=peek(n->stack); } 
    pop(n->stack);
}
if(n->pos==peek(n->stack)){ 
    n->OK=0; 
} else {
    n->OK=1; 
}
pop(n->stack);
                                                            

zero_or_more:
//zero or more
if( n_OK(n)==1 ) {
    push(n->stack,n->pos);
    {body}
    if(n->OK==0) { n->pos=peek(n->stack); }
    pop(n->stack);
} 




compare:
// order {order}
if( n_OK(n)==1 && stricmp(n,(const char * ) "{compare_value}")==0) {
    n->OK=1;
    n->pos+={compare_value_length};
    if(n->pos>=n->len) n->pos= -1;
} else {
    n->OK=0;
}

optional:
//optional
if( n_OK(n)==1 ) {
    push(n->stack,n->pos);
    {body}
    if(n->OK==0) { 
        n->OK=1; 
        n->pos=peek(n->stack); 
    }
    pop(n->stack);
}






not:
//NOT
if( n_OK(n)==1 ) {
    push(n->stack,n->pos);
    {body}
    if (n->OK==1 ) {
        n->OK=0;
        n->pos=peek(n->stack);
    } else { 
        n->OK=1;
        n->pos+=1;
        if(n->pos>=n->len) n->pos= -1;
    }
    pop(n->stack);
}//end NOT

range:
(n->value[n->pos]>='{range_1}' && n->value[n->pos]<='{range_2}')

char:
if( n_OK(n)==1 && ( 
{conditions}
) ) {
    n->OK=1;
    n->pos++; 
    if(n->pos>=n->len) n->pos= -1;
} else {     
    n->OK=0;
} // end char

or_compare:
 n->value[n->pos]=='{compare_value}'

compare_method:
    //external -> {order}
    if( n_OK(n)==1 ) { n = match_{function_name}(n,name,depth+1); }

compare_method_self:
    //recursion -> {order}
    //if(strcmp(name,last_method)==0) {
    if( n_OK(n)==1 && start_pos!=n->pos) { n = match_{function_name}(n,name,depth+1); }
    //}


group:
// GROUP
if( n_OK(n)==1 ) {
    {body}
}

signature:
node_t * match_{body}(node_t *n,const char *last_method,int depth);


signature2:
node_t *match_function(char * data);
